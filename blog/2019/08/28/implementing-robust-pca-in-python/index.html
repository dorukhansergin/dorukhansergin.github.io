<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Dorukhan" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="machine-learning, high-dimensionality, research, " />

<meta property="og:title" content="Implementing Robust PCA in Python "/>
<meta property="og:url" content="/blog/2019/08/28/implementing-robust-pca-in-python/" />
<meta property="og:description" content="In a previous post, I introduce robust PCA, the math behind and an example where I put the model in action. This post I will share my Python implementation of robust PCA. If you don’t have any background in convex optimization, some of the discussions here might be boring …" />
<meta property="og:site_name" content="Dorukhan&#39;s Blog" />
<meta property="og:article:author" content="Dorukhan" />
<meta property="og:article:published_time" content="2019-08-28T00:00:00+01:00" />
<meta name="twitter:title" content="Implementing Robust PCA in Python ">
<meta name="twitter:description" content="In a previous post, I introduce robust PCA, the math behind and an example where I put the model in action. This post I will share my Python implementation of robust PCA. If you don’t have any background in convex optimization, some of the discussions here might be boring …">

        <title>Implementing Robust PCA in Python  · Dorukhan&#39;s Blog
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
<link rel="stylesheet" href="/theme/css/style.min.css?605d3017">

        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dorukhan&#39;s Blog - Full Atom Feed" />
        <link href="/feeds/all.rss" type="application/rss+xml" rel="alternate" title="Dorukhan&#39;s Blog - Full RSS Feed" />


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="/"><span class=site-name>Dorukhan's Blog</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       "/"
                                    >Home</a>
                                </li>
                                <li ><a href="/about/">About</a></li>
                                <li ><a href="/categories">Categories</a></li>
                                <li ><a href="/tags">Tags</a></li>
                                <li ><a href="/archives">Archives</a></li>
                                <li><form class="navbar-search" action="/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="/blog/2019/08/28/implementing-robust-pca-in-python/">
                Implementing Robust <span class="caps">PCA</span> in&nbsp;Python
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <hr>
<p>In <a href="/blog/2019/08/01/from-pca-to-robust-pca/">a previous post</a>, I introduce robust <span class="caps">PCA</span>, the math behind and an example where I put the model in action.
This post I will share my Python implementation of robust <span class="caps">PCA</span>.
If you don&#8217;t have any background in convex optimization, some of the discussions here might be boring or irrelevant.
If you really just need an implementation of robust <span class="caps">PCA</span>, skip the background section and you&#8217;ll find the code&nbsp;below.</p>
<h2 id="first-some-background">First Some Background<a class="headerlink" href="#first-some-background" title="Permanent link">&para;</a></h2>
<h3 id="alternating-direction-method-of-multipliers">Alternating Direction Method of Multipliers<a class="headerlink" href="#alternating-direction-method-of-multipliers" title="Permanent link">&para;</a></h3>
<p>Say you have a convex optimization problem that looks like&nbsp;this:
</p>
<div class="math">$$
\begin{equation*}
\begin{aligned}   
&amp; \min_{X, Z}    &amp; &amp; f(X) + g(Z) \\   &amp; \text{subject to}    &amp; &amp; AX + BZ = C \\\end{aligned}\end{equation*}
$$</div>
<p>
where <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are convex.
The augmented Lagrangian looks like&nbsp;this:
</p>
<div class="math">$$
\mathcal{L}(X, Z, Y) = f(X) + g(Z) + \langle Y,C-AX-BZ\rangle + \frac{\mu}{2}\|C-AX-BZ\|_F^2
$$</div>
<p>
 If you feel the need to understand how we got here, I suggest reading the second chapter of <a href="https://stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf">Boyd <em>et al</em>&#8216;s classic report</a> on&nbsp;this.</p>
<p><span class="caps">ADMM</span> propses an iterative approach using the Lagrangian.
Say we are at iteration <span class="math">\(k\)</span> and we are given from previous iteration <span class="math">\(X^k\)</span>, <span class="math">\(Z^k\)</span>, <span class="math">\(Y^k\)</span>.
The required iterations for step <span class="math">\(k+1\)</span> will&nbsp;become:
</p>
<div class="math">$$
\begin{aligned}
    X^{k+1} &amp;= \underset{X}{\mathrm{argmin}}\mathcal{L}(X, Z^k, Y^k) \\
    Z^{k+1} &amp;= \underset{Z}{\mathrm{argmin}}\mathcal{L}(X^{k+1}, Z, Y^k) \\
    Y^{k+1} &amp;= Y^k + \mu(C-AX^{k+1}-BZ^{k+1}) 
\end{aligned}
$$</div>
<p>If you have a closed form solution for the updates of <span class="math">\(X^{k+1}\)</span> and <span class="math">\(Z^{k+1}\)</span>, you&#8217;re in good&nbsp;luck.</p>
<p><span class="caps">ADMM</span> can be thought of as a tug-of-war between optimality gap and feasibility of the primal problem.
This can be used to set up a systematic way to early stop the algorithm and/or play around with <span class="math">\(\mu\)</span> over iterations.
According to <a href="https://stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf">Boyd <em>et al</em></a>, the primal residual and dual residuals of the problem can be quantified as <span class="math">\(r^k = \|AX^k-BZ^k-C\|_F^2\)</span> and <span class="math">\(h^k = \|\mu_k A^\top B(Z^k - Z^{k+1})\|_F^2\)</span>, respectively.
Algorithm can be terminated when both of these quantities are below a certain tolerance and advise on choosing these tolerance values also mentioned in the same report.
To bias the algorithm towards reaching primal feasibility one can dial up <span class="math">\(\mu\)</span> (thus increasing the penalty on primal residuals) or dial it down for speeding up closing the optimality gap.
The <span class="math">\(\mu_k\)</span> update then&nbsp;becomes:
</p>
<div class="math">$$
\mu_{k+1} = \begin{cases} 
\rho\mu_k &amp; \text{if } r^k &gt; \tau s^k \\ 
\mu_k\mathbin{/}\rho &amp; \text{if } s^k &gt; \tau r^k \\
\mu_k &amp; \text{o.w.}
        \end{cases}
$$</div>
<p>
This gives us an almost complete look at <span class="caps">ADMM</span>.
Now we will see how we can write a special case of <span class="caps">ADMM</span> for robust <span class="caps">PCA</span>.</p>
<h3 id="robust-pca-via-admm">Robust <span class="caps">PCA</span> via <span class="caps">ADMM</span><a class="headerlink" href="#robust-pca-via-admm" title="Permanent link">&para;</a></h3>
<p>Let&#8217;s refresh our memories.
The optimization problem for robust <span class="caps">PCA</span>&nbsp;was:
</p>
<div class="math">$$
\begin{equation*}\begin{aligned}   &amp; \min_{L}    &amp; &amp; \|L\|_* + \lambda\|S\|_1 \\   &amp; \text{subject to}    &amp; &amp; L + S = M \\\end{aligned}\end{equation*}
$$</div>
<p>
Then we can make following&nbsp;analogies:
</p>
<div class="math">$$
\begin{aligned}
f(L) &amp;= \|L\|_* \\
g(S) &amp;= \|S\|_1 \\
A &amp;= I \\
B &amp;= I \\
C &amp;= M \\
\end{aligned}
$$</div>
<p>
I&#8217;m sorry about the change of notation here but I feel that&#8217;s the best&nbsp;way.</p>
<p>What about minimization steps?
I won&#8217;t go into the details of their derivation but I hope to point you in the right direction if you want to do it on your&nbsp;own.
</p>
<div class="math">$$
\begin{aligned}
L^{k+1} &amp;= \underset{L}{\mathrm{argmin}}\mathcal{L}(L, S^k, Y^k) \\
&amp; =\|L\|_* + \langle Y^k,M-L-S\rangle + \frac{\mu_k}{2}\|M-L-S\|_F^2 \\
&amp; \propto  (1/\mu_k)\|L\|_* + \|M-S^k+Y^k/\mu^k\|_F^2 \\
&amp; = \mathcal{D}_{1\mathbin{/}\mu_k}(M-S^k+Y^k/\mu^k)
\end{aligned}
$$</div>
<p>
where <span class="math">\(\mathcal{D}_{1\mathbin{/}\mu_k}\)</span> is the singular value thresholding operator. 
Please refer to Section 2.1 of <a href="https://statweb.stanford.edu/~candes/papers/SVT.pdf">Cai <em>et al.</em></a> for detailed explanation of&nbsp;it.</p>
<p>Then
</p>
<div class="math">$$
\begin{aligned}
S^{k+1} &amp;= \underset{S}{\mathrm{argmin}}\mathcal{L}(L^{k+1}, S, Y^k) \\
&amp;= \lambda\|S\|_1 + \langle Y^k,M-L-S\rangle + \frac{\mu_k}{2}\|M-L-S\|_F^2 \\
&amp;\propto (\lambda/\mu_k)\|S\|_1 + \|X-L-Y^k/\mu^k\|_F^2 \\
&amp;= \mathcal{P}_{(\lambda/\mu_k)}(X-L-Y^k/\mu^k)
\end{aligned}
$$</div>
<p>
where <span class="math">\(\mathcal{P}_{1\mathbin{/}\mu_k}\)</span> is the soft thresholding operator.
Section 6.5.2 of <a href="https://web.stanford.edu/~boyd/papers/pdf/prox_algs.pdf">Boyd <em>et al.</em></a> is a good reference for the soft thresholding operator.
It is commonly used to solve lasso regression.
It is also a subroutine of the singular value thresholding&nbsp;operator.</p>
<h2 id="implementation-in-python-with-numpy">Implementation in Python with Numpy<a class="headerlink" href="#implementation-in-python-with-numpy" title="Permanent link">&para;</a></h2>
<p>Now that we have all the steps ready, we can start implementing. 
We will only need a Python environment with version 3.6+ (just because I like static type hinting feature) and numpy.
You can easily set this up with conda or&nbsp;Pipenv.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
</pre></div>
</td></tr></table>

<p>Let&#8217;s first start by defining the proximal&nbsp;operators: </p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">soft_thresholding</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Soft thresholding operator as explained in Section 6.5.2 of https://web.stanford.edu/~boyd/papers/pdf/prox_algs.pdf</span>
<span class="sd">    Solves the following problem:</span>
<span class="sd">    argmin_x (1/2)*||x-y||_F^2 + lmb*||x||_1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target vector/matrix</span>
<span class="sd">        lmb : float</span>
<span class="sd">            Penalty parameter</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        x : np.ndarray</span>
<span class="sd">            argmin solution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">svd_shrinkage</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SVD shrinakge operator as explained in Theorem 2.1 of https://statweb.stanford.edu/~candes/papers/SVT.pdf</span>
<span class="sd">    Solves the following problem:</span>
<span class="sd">    argmin_x (1/2)*||x-y||_F^2 + tau*||x||_*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target vector/matrix</span>
<span class="sd">        tau : float</span>
<span class="sd">            Penalty parameter</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        x : np.ndarray</span>
<span class="sd">            argmin solution</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">s_t</span> <span class="o">=</span> <span class="n">soft_thresholding</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">U</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s_t</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vh</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>I want my <span class="caps">API</span> to follow a <code>scikit-learn</code>-like design so here&#8217;s how it should like at the&nbsp;end:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">rpca</span> <span class="o">=</span> <span class="n">RobustPCA</span><span class="p">(</span><span class="n">lmb</span><span class="o">=</span><span class="mf">4e-3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">L</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">rpca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>The only difference is that <code>.fit</code> function doesn&#8217;t normally return anything in <code>scikit-learn</code> but I want it to return the low-rank and sparse components for the sake of&nbsp;simplicity.</p>
<p>Then I start building the class with my main method <code>.fit</code>. Starting with <code>.fit</code> gives me a good idea about what other parameters I have to initialize or what submethods I&#8217;ll end up having to&nbsp;implement:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0_</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_J</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">S_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_</span><span class="p">):</span>
        <span class="c1"># Solve argmin_L ||X - (L + S) + Y/mu||_F^2 + (lmb/mu)*||L||_*</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">svd_shrinkage</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">+</span> <span class="n">Y</span><span class="o">/</span><span class="n">mu</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">mu</span><span class="p">)</span>

        <span class="c1"># Solve argmin_S ||X - (L + S) + Y/mu||_F^2 + (lmb/mu)*||S||_1</span>
        <span class="n">S_last</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">soft_thresholding</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="n">Y</span><span class="o">/</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmb_</span><span class="o">/</span><span class="n">mu</span><span class="p">)</span>

        <span class="c1"># Update dual variables Y &lt;- Y + mu * (X - S - L)</span>
        <span class="n">Y</span> <span class="o">+=</span> <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_residuals</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">S_last</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

        <span class="c1"># Check stopping cirteria</span>
        <span class="n">tol_r</span><span class="p">,</span> <span class="n">tol_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_tols</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tol_r</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">tol_h</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Update mu</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_mu</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span>
</pre></div>
</td></tr></table>

<p>The private methods I need, <code>._J</code>, <code>._get_residuals</code>,<code>._update_tols</code> and <code>._update_mu</code> are implemented as&nbsp;follows.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_get_residuals</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">S_last</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">primal_residual</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">)</span>
    <span class="n">dual_residual</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="n">S_last</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">primal_residual</span><span class="p">,</span> <span class="n">dual_residual</span>

<span class="k">def</span> <span class="nf">_update_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_</span> <span class="o">*</span> <span class="n">h</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_</span>
    <span class="k">elif</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_</span> <span class="o">*</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mu</span>

<span class="k">def</span> <span class="nf">_update_tols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="n">tol_primal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_rel_</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
    <span class="n">tol_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_rel_</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tol_primal</span><span class="p">,</span> <span class="n">tol_dual</span>

<span class="k">def</span> <span class="nf">_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lmb</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="o">/</span><span class="n">lmb</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>We haven&#8217;t talked about <code>._J</code>. It&#8217;s a dual variable initialization technqiue discussed in Section 3.1 of <a href="https://people.eecs.berkeley.edu/~yima/matrix-rank/Files/rpca_algorithms.pdf">Lin <em>et al.</em></a>.</p>
<p>The last part is to write an <code>__init__</code> function, add some docstrings and wrap everything up in a&nbsp;class.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RobustPCA</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves robust PCA using Inexact ALM as explained in Algorithm 5 of https://arxiv.org/pdf/1009.5055.pdf</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        lmb: </span>
<span class="sd">            penalty on sparse errors</span>
<span class="sd">        mu_0: </span>
<span class="sd">            initial lagrangian penalty</span>
<span class="sd">        rho: </span>
<span class="sd">            learning rate</span>
<span class="sd">        tau:</span>
<span class="sd">            mu update criterion parameter</span>
<span class="sd">        max_iter:</span>
<span class="sd">            max number of iterations for the algorithm to run</span>
<span class="sd">        tol_rel:</span>
<span class="sd">            relative tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lmb</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mu_0</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                 <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">mu_0</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">lmb</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">rho</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">max_iter</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">tol_rel</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_0_</span> <span class="o">=</span> <span class="n">mu_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmb_</span> <span class="o">=</span> <span class="n">lmb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter_</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_rel_</span> <span class="o">=</span> <span class="n">tol_rel</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits robust PCA to X and returns the low-rank and sparse components</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            X:</span>
<span class="sd">                Original data matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            L:</span>
<span class="sd">                Low rank component of X</span>
<span class="sd">            S:</span>
<span class="sd">                Sparse error component of X</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0_</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_J</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">S_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_</span><span class="p">):</span>
            <span class="c1"># Solve argmin_L ||X - (L + S) + Y/mu||_F^2 + (lmb/mu)*||L||_*</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">svd_shrinkage</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">+</span> <span class="n">Y</span><span class="o">/</span><span class="n">mu</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">mu</span><span class="p">)</span>

            <span class="c1"># Solve argmin_S ||X - (L + S) + Y/mu||_F^2 + (lmb/mu)*||S||_1</span>
            <span class="n">S_last</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">soft_thresholding</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="n">Y</span><span class="o">/</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmb_</span><span class="o">/</span><span class="n">mu</span><span class="p">)</span>

            <span class="c1"># Update dual variables Y &lt;- Y + mu * (X - S - L)</span>
            <span class="n">Y</span> <span class="o">+=</span> <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_residuals</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">S_last</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

            <span class="c1"># Check stopping cirteria</span>
            <span class="n">tol_r</span><span class="p">,</span> <span class="n">tol_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_tols</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tol_r</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">tol_h</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Update mu</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_mu</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span>

    <span class="k">def</span> <span class="nf">_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lmb</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function J() required for initialization of dual variables as advised in Section 3.1 of </span>
<span class="sd">        https://people.eecs.berkeley.edu/~yima/matrix-rank/Files/rpca_algorithms.pdf            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="o">/</span><span class="n">lmb</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_residuals</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">S_last</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">primal_residual</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">)</span>
        <span class="n">dual_residual</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="n">S_last</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">primal_residual</span><span class="p">,</span> <span class="n">dual_residual</span>

    <span class="k">def</span> <span class="nf">_update_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_</span> <span class="o">*</span> <span class="n">h</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_</span>
        <span class="k">elif</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_</span> <span class="o">*</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu</span>

    <span class="k">def</span> <span class="nf">_update_tols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="n">tol_primal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_rel_</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
        <span class="n">tol_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_rel_</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tol_primal</span><span class="p">,</span> <span class="n">tol_dual</span>
</pre></div>
</td></tr></table>

<h3 id="complexity-analysis">Complexity Analysis<a class="headerlink" href="#complexity-analysis" title="Permanent link">&para;</a></h3>
<p>All the norms and matrix additions/summations/multiplications are elementwise operations so that they&#8217;re <span class="math">\(\mathcal{O}(np)\)</span> given that our matrix <span class="math">\(X\)</span> is an <span class="math">\(n\times p\)</span> matrix.
The major bottleneck of algorithms involving nuclear norm is that they typically require singular value thresholding which reqiuires <span class="caps">SVD</span>.
Since we&#8217;re computing a skinny <span class="caps">SVD</span>, the complexity will be <span class="math">\(\mathcal{O}(np\min(n,p))\)</span>.
<span class="caps">SVD</span> also requires to fit the entire data into the memory so it&#8217;s inefficient in that sense too.
This can become a huge issue if you want to scale this algorithm and the literature has addressed this issue in certain ways which I hope to discuss in another&nbsp;post.</p>
<h3 id="things-to-try">Things to Try<a class="headerlink" href="#things-to-try" title="Permanent link">&para;</a></h3>
<p>The algorithm is ready to use, but here are a few suggestions I have for you to play around with the code a little and interact with&nbsp;it:</p>
<ul>
<li>Plot the interplay of <code>r</code>, <code>h</code> and <code>mu</code> over iterations to see the tug-of-war I mentioned earlier in&nbsp;action.</li>
<li>Take one frame and record its evolution over the course of the algorithm. Especially observe how the sparse component for that frame <code>S[frame,:]</code> changes over&nbsp;time.</li>
<li>You can estimate the rank of <code>L</code></li>
</ul>
<p>A very accesible dataset is the <a href="http://vision.ucsd.edu/~leekc/ExtYaleDatabase/ExtYaleB.html">cropped Yale B</a> dataset where you have faces of different people taken under various lighting conditions.
Just pick one or two people and incldue all the illumination conditions they have to see if you can extract their clean face in the low-rank&nbsp;component.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>


            
            
            






            <hr/>
<section>
    <h2>Keep Reading</h2>
<ul class="related-posts-list">
<li><a href="/blog/2019/08/01/from-pca-to-robust-pca/" title="From PCA to Robust-PCA">From PCA to Robust-PCA</a></li>
</ul>
<hr />
</section>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="/blog/2019/08/01/from-pca-to-robust-pca/" title="Previous: From PCA to Robust-PCA">From PCA to Robust-PCA</a></li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
    <h4>Reading Time</h4>
    <p>~8 min read</p>
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2019-08-28T00:00:00+01:00">Aug 28, 2019</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories#research-ref">research</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="/tags#high-dimensionality-ref">high-dimensionality
                    <span>2</span>
</a></li>
                <li><a href="/tags#machine-learning-ref">machine-learning
                    <span>2</span>
</a></li>
            </ul>
<h4>Stay in Touch</h4>
<div id="sidebar-social-link">
    <a href="http://github.com/dorukhansergin" title="" target="_blank" rel="nofollow">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
    <a href="https://linkedin.com/in/dorukhansergin/" title="" target="_blank" rel="nofollow">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="LinkedIn" role="img" viewBox="0 0 512 512" fill="#fff"><rect width="512" height="512" rx="15%" fill="#0077b5"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
    </a>
</div>
            





            





        </div>
        </section>
</div>
</article>
                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>